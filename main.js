/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PreviewModePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  useItalicTitle: true,
  reuseEmptyTab: true,
  promoteOldPreview: true,
  jumpToDuplicate: true,
  openNewTabAtEnd: false
};
var PREVIEW_CLASS = "is-preview-tab";
var PreviewModePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.previewByPanel = /* @__PURE__ */ new Map();
    this.leafHistory = /* @__PURE__ */ new WeakMap();
    // Click tracking - removed, not needed anymore
    this.clickIntent = null;
    this.clickFile = null;
    this.clickTimestamp = 0;
    // New file tracking
    this.newlyCreatedFiles = /* @__PURE__ */ new Set();
    // Processing guard
    this.isProcessingOpen = false;
    this.internalOpenPaths = /* @__PURE__ */ new Set();
    /* ------------------------ State Management ------------------------ */
    this.captureLeafState = (leaf) => {
      const path = this.getLeafFilePath(leaf);
      const isPreview = this.isPanelPreviewLeaf(leaf);
      const isPermanent = !isPreview && leaf.view.getViewType() !== "empty";
      const isEmpty = leaf.view.getViewType() === "empty";
      const viewType = leaf.view.getViewType();
      this.leafHistory.set(leaf, { path, isPreview, isPermanent, isEmpty, viewType });
    };
    /* ------------------------ Strategy A: Gesture Detection ------------------------ */
    this.handleDblClick = (evt) => {
      const target = evt.target;
      const file = this.extractFileFromClick(target);
      if (!file)
        return;
      if (evt.ctrlKey || evt.metaKey || evt.shiftKey)
        return;
      evt.preventDefault();
      evt.stopPropagation();
      console.log("[PreviewPlugin] \u2605\u2605\u2605 Double-click detected:", file.path, "- handling directly");
      this.handleDoubleClickDirect(file);
    };
    this.handleDoubleClickDirect = async (file) => {
      const activeLeaf = this.app.workspace.getLeaf(false);
      if (!activeLeaf)
        return;
      const currentPath = this.getLeafFilePath(activeLeaf);
      const panel = this.getPanelParent(activeLeaf);
      if (panel && this.settings.jumpToDuplicate) {
        const existing = this.findLeafWithFileInPanel(file, panel);
        if (existing && existing !== activeLeaf) {
          console.log("[PreviewPlugin] Jumping to existing tab");
          this.app.workspace.setActiveLeaf(existing, { focus: true });
          this.markAsPermanent(existing);
          this.captureLeafState(existing);
          return;
        }
      }
      if (currentPath === file.path) {
        console.log("[PreviewPlugin] Same file - promoting to permanent");
        this.markAsPermanent(activeLeaf);
        this.captureLeafState(activeLeaf);
        return;
      }
      const currentState = this.getCurrentTabState(activeLeaf);
      if (currentState === "permanent") {
        console.log("[PreviewPlugin] Opening in new permanent tab");
        const newLeaf = this.createNewLeafInPanelOrNull(activeLeaf);
        if (newLeaf) {
          this.internalOpenPaths.add(file.path);
          await newLeaf.openFile(file);
          this.app.workspace.setActiveLeaf(newLeaf, { focus: true });
          this.markAsPermanent(newLeaf);
          this.captureLeafState(newLeaf);
        }
      } else {
        console.log("[PreviewPlugin] Using current tab as permanent");
        this.internalOpenPaths.add(file.path);
        await activeLeaf.openFile(file);
        this.markAsPermanent(activeLeaf);
        this.captureLeafState(activeLeaf);
      }
    };
    this.handleHeaderDblClick = (evt) => {
      const target = evt.target;
      const tabHeader = target.closest(".workspace-tab-header");
      if (!tabHeader)
        return;
      for (const [, leaf] of this.previewByPanel.entries()) {
        if (this.getTabHeaderEl(leaf) === tabHeader) {
          evt.preventDefault();
          evt.stopPropagation();
          this.markAsPermanent(leaf);
          this.captureLeafState(leaf);
          return;
        }
      }
    };
    this.handleInput = (evt) => {
      const target = evt.target;
      if (target.closest(".view-header") || target.classList.contains("inline-title")) {
        const leaf = this.getLeafFromDom(target);
        if (leaf && this.isPanelPreviewLeaf(leaf)) {
          this.markAsPermanent(leaf);
          this.captureLeafState(leaf);
        }
      }
    };
    /* ------------------------ Strategy B: File Open Handler (Main Logic) ------------------------ */
    this.handleFileOpen = async (file) => {
      this.isProcessingOpen = true;
      try {
        if (!file) {
          await this.handleNonFileView();
          return;
        }
        const activeLeaf = this.app.workspace.getLeaf(false);
        if (!activeLeaf)
          return;
        const previousState = this.leafHistory.get(activeLeaf);
        const isNewFile = this.newlyCreatedFiles.has(file.path);
        const isDailyNote = this.isDailyNoteFile(file);
        console.log("[PreviewPlugin] \u25BA\u25BA\u25BA File open:", {
          file: file.path,
          isNewFile,
          isDailyNote
        });
        const userIntent = this.determineUserIntent(isNewFile, isDailyNote);
        const wasHijacked = this.wasTabHijacked(activeLeaf, previousState, file);
        if (wasHijacked) {
          await this.restoreHijackedTab(activeLeaf, previousState, file, userIntent);
        } else {
          await this.applyIntent(activeLeaf, file, userIntent, previousState);
        }
      } finally {
        setTimeout(() => {
          this.isProcessingOpen = false;
        }, 100);
      }
    };
    /* ------------------------ Helpers ------------------------ */
    this.resolveToFile = (candidate) => {
      if (!candidate)
        return null;
      const byPath = this.app.vault.getAbstractFileByPath(candidate);
      if (byPath instanceof import_obsidian.TFile)
        return byPath;
      const byLink = this.app.metadataCache.getFirstLinkpathDest(candidate, "");
      if (byLink instanceof import_obsidian.TFile)
        return byLink;
      return null;
    };
    this.extractFileFromClick = (target) => {
      var _a, _b, _c, _d, _e;
      const attrKeys = ["data-path", "data-href", "data-file", "data-source-path", "data-resource-path", "data-link"];
      for (const k of attrKeys) {
        const v = (_a = target.closest(`[${k}]`)) == null ? void 0 : _a.getAttribute(k);
        const f = this.resolveToFile(v != null ? v : null);
        if (f)
          return f;
      }
      const searchResult = target.closest(".search-result-file-title");
      if (searchResult) {
        const f = this.resolveToFile((_c = (_b = searchResult.textContent) == null ? void 0 : _b.trim()) != null ? _c : null);
        if (f)
          return f;
      }
      const searchMatch = target.closest(".search-result-file-match");
      if (searchMatch) {
        const container = searchMatch.closest(".search-result-container");
        if (container) {
          const titleEl = container.querySelector(".search-result-file-title");
          if (titleEl) {
            const f = this.resolveToFile((_e = (_d = titleEl.textContent) == null ? void 0 : _d.trim()) != null ? _e : null);
            if (f)
              return f;
          }
        }
      }
      const a = target.closest("a.internal-link, a.external-link");
      if (a) {
        const href = a.getAttribute("href");
        if (href) {
          const f = this.resolveToFile(href);
          if (f)
            return f;
        }
      }
      return null;
    };
    this.getLeafFromDom = (target) => {
      let found = null;
      const content = target.closest(".workspace-leaf-content");
      if (content) {
        this.app.workspace.iterateAllLeaves((l) => {
          if (found)
            return;
          if (l.view.containerEl === content)
            found = l;
        });
      }
      return found;
    };
    this.getPanelParent = (leaf) => {
      const parent = leaf.parent;
      return parent && Array.isArray(parent.children) ? parent : null;
    };
    this.isPanelPreviewLeaf = (leaf) => {
      const panel = this.getPanelParent(leaf);
      return !!panel && this.previewByPanel.get(panel) === leaf;
    };
    this.cleanupPreviewMap = () => {
      for (const [panel, leaf] of this.previewByPanel.entries()) {
        if (!this.isLeafStillPresent(leaf))
          this.previewByPanel.delete(panel);
      }
    };
    this.isLeafStillPresent = (leaf) => {
      let found = false;
      this.app.workspace.iterateAllLeaves((l) => {
        if (l === leaf)
          found = true;
      });
      return found;
    };
    this.getLeafFilePath = (leaf) => {
      const view = leaf.view;
      if (view instanceof import_obsidian.FileView && view.file)
        return view.file.path;
      return null;
    };
    this.getTabHeaderEl = (leaf) => {
      var _a;
      return (_a = leaf.tabHeaderEl) != null ? _a : null;
    };
    this.markAsPreview = (leaf) => {
      const panel = this.getPanelParent(leaf);
      if (!panel)
        return;
      this.previewByPanel.set(panel, leaf);
      const header = this.getTabHeaderEl(leaf);
      if (header && this.settings.useItalicTitle)
        header.classList.add(PREVIEW_CLASS);
    };
    this.markAsPermanent = (leaf) => {
      const panel = this.getPanelParent(leaf);
      if (panel && this.previewByPanel.get(panel) === leaf) {
        this.previewByPanel.delete(panel);
      }
      const header = this.getTabHeaderEl(leaf);
      if (header)
        header.classList.remove(PREVIEW_CLASS);
    };
    this.findLeafWithFileInPanel = (file, panel) => {
      let found = null;
      this.app.workspace.iterateAllLeaves((l) => {
        if (found)
          return;
        if (this.getPanelParent(l) === panel && this.getLeafFilePath(l) === file.path)
          found = l;
      });
      return found;
    };
    this.findLeafHoldingFile = (file) => {
      let found = null;
      this.app.workspace.iterateAllLeaves((l) => {
        if (found)
          return;
        if (this.getLeafFilePath(l) === file.path)
          found = l;
      });
      return found;
    };
    this.createNewLeafInPanelOrNull = (baseLeaf) => {
      const panel = this.getPanelParent(baseLeaf);
      if (!panel)
        return null;
      const ws = this.app.workspace;
      const idx = panel.children.indexOf(baseLeaf);
      const insertIdx = this.settings.openNewTabAtEnd ? panel.children.length : idx + 1;
      try {
        return ws.createLeafInParent(panel, insertIdx);
      } catch (e) {
        return null;
      }
    };
  }
  async onload() {
    console.log("[PreviewPlugin] v2 - Event-driven Architecture");
    await this.loadSettings();
    this.addSettingTab(new PreviewModeSettingTab(this.app, this));
    this.registerDomEvent(document, "dblclick", this.handleDblClick, true);
    this.registerDomEvent(document, "dblclick", this.handleHeaderDblClick, true);
    this.registerDomEvent(document, "input", this.handleInput, true);
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf)
          this.captureLeafState(leaf);
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        const leaf = this.findLeafHoldingFile(file);
        if (leaf)
          this.captureLeafState(leaf);
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (!(file instanceof import_obsidian.TFile) || file.extension !== "md")
          return;
        this.newlyCreatedFiles.add(file.path);
        setTimeout(() => {
          this.newlyCreatedFiles.delete(file.path);
        }, 5e3);
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file) => {
        if (!(file instanceof import_obsidian.TFile))
          return;
        this.app.workspace.iterateAllLeaves((leaf) => {
          if (this.getLeafFilePath(leaf) === file.path && this.isPanelPreviewLeaf(leaf)) {
            this.markAsPermanent(leaf);
            this.captureLeafState(leaf);
          }
        });
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", (_editor, info) => {
        const leaf = info == null ? void 0 : info.leaf;
        if (leaf && this.isPanelPreviewLeaf(leaf)) {
          this.markAsPermanent(leaf);
          this.captureLeafState(leaf);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.cleanupPreviewMap();
        this.app.workspace.iterateAllLeaves((leaf) => this.captureLeafState(leaf));
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (this.isProcessingOpen)
          return;
        if (file instanceof import_obsidian.TFile && this.internalOpenPaths.has(file.path)) {
          this.internalOpenPaths.delete(file.path);
          const leaf = this.findLeafHoldingFile(file);
          if (leaf)
            this.captureLeafState(leaf);
          return;
        }
        this.handleFileOpen(file);
      })
    );
    this.app.workspace.iterateAllLeaves((leaf) => this.captureLeafState(leaf));
  }
  onunload() {
    document.querySelectorAll(`.${PREVIEW_CLASS}`).forEach((el) => el.classList.remove(PREVIEW_CLASS));
    this.previewByPanel.clear();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  determineUserIntent(isNewFile, isDailyNote) {
    if (isNewFile) {
      if (isDailyNote)
        return "daily-note";
      return "new-note";
    }
    return "preview";
  }
  wasTabHijacked(leaf, previousState, newFile) {
    if (!previousState) {
      console.log("[PreviewPlugin] No previous state - not hijacked");
      return false;
    }
    console.log("[PreviewPlugin] Checking hijack:", {
      wasPermanent: previousState.isPermanent,
      oldPath: previousState.path,
      newPath: newFile.path,
      pathChanged: previousState.path !== newFile.path
    });
    if (previousState.isPermanent && previousState.path && previousState.path !== newFile.path) {
      console.log("[PreviewPlugin] \u{1F6A8} HIJACK DETECTED! Permanent tab was changed");
      return true;
    }
    return false;
  }
  async restoreHijackedTab(hijackedLeaf, previousState, newFile, userIntent) {
    console.log("[PreviewPlugin] \u{1F527} RESTORING hijacked tab...");
    const oldFile = this.app.vault.getAbstractFileByPath(previousState.path);
    if (oldFile instanceof import_obsidian.TFile) {
      console.log("[PreviewPlugin] Restoring old file:", oldFile.path);
      this.internalOpenPaths.add(oldFile.path);
      await hijackedLeaf.openFile(oldFile);
      this.markAsPermanent(hijackedLeaf);
      this.captureLeafState(hijackedLeaf);
    }
    console.log("[PreviewPlugin] Opening new file in new tab:", newFile.path, "with intent:", userIntent);
    await this.openInNewTab(hijackedLeaf, newFile, userIntent);
  }
  async openInNewTab(baseLeaf, file, intent) {
    const panel = this.getPanelParent(baseLeaf);
    if (intent === "preview" && panel) {
      const existingPreview = this.previewByPanel.get(panel);
      if (existingPreview && this.isLeafStillPresent(existingPreview)) {
        this.internalOpenPaths.add(file.path);
        await existingPreview.openFile(file);
        this.app.workspace.setActiveLeaf(existingPreview, { focus: true });
        this.markAsPreview(existingPreview);
        this.captureLeafState(existingPreview);
        return;
      }
    }
    const newLeaf = this.createNewLeafInPanelOrNull(baseLeaf);
    if (newLeaf) {
      this.internalOpenPaths.add(file.path);
      await newLeaf.openFile(file);
      this.app.workspace.setActiveLeaf(newLeaf, { focus: true });
      if (intent === "preview") {
        this.markAsPreview(newLeaf);
      } else {
        this.markAsPermanent(newLeaf);
      }
      this.captureLeafState(newLeaf);
    }
  }
  async applyIntent(leaf, file, intent, previousState) {
    var _a, _b;
    const wasEmpty = (_a = previousState == null ? void 0 : previousState.isEmpty) != null ? _a : leaf.view.getViewType() === "empty";
    const wasPreview = (_b = previousState == null ? void 0 : previousState.isPreview) != null ? _b : false;
    if (intent === "new-note" || intent === "daily-note") {
      if (wasEmpty) {
        this.markAsPermanent(leaf);
        this.captureLeafState(leaf);
      } else if (wasPreview) {
        this.markAsPermanent(leaf);
        this.captureLeafState(leaf);
        await this.openInNewTab(leaf, file, "permanent");
      } else {
        await this.openInNewTab(leaf, file, "permanent");
      }
      return;
    }
    if (wasEmpty) {
      const panel = this.getPanelParent(leaf);
      const existingPreview = panel ? this.previewByPanel.get(panel) : null;
      if (existingPreview && existingPreview !== leaf && this.settings.promoteOldPreview) {
        this.markAsPermanent(existingPreview);
        this.captureLeafState(existingPreview);
      }
      this.markAsPreview(leaf);
      this.captureLeafState(leaf);
    } else if (wasPreview) {
      this.markAsPreview(leaf);
      this.captureLeafState(leaf);
    } else {
      this.markAsPreview(leaf);
      this.captureLeafState(leaf);
    }
  }
  async handleNonFileView() {
    var _a, _b, _c;
    const leaf = this.app.workspace.getLeaf(false);
    if (!leaf)
      return;
    const previousState = this.leafHistory.get(leaf);
    const wasEmpty = (_a = previousState == null ? void 0 : previousState.isEmpty) != null ? _a : leaf.view.getViewType() === "empty";
    const wasPreview = (_b = previousState == null ? void 0 : previousState.isPreview) != null ? _b : false;
    const wasPermanent = (_c = previousState == null ? void 0 : previousState.isPermanent) != null ? _c : false;
    if (wasEmpty || wasPreview) {
      this.markAsPreview(leaf);
      this.captureLeafState(leaf);
    } else if (wasPermanent) {
      if (previousState == null ? void 0 : previousState.path) {
        const oldFile = this.app.vault.getAbstractFileByPath(previousState.path);
        if (oldFile instanceof import_obsidian.TFile) {
          this.internalOpenPaths.add(oldFile.path);
          await leaf.openFile(oldFile);
          this.markAsPermanent(leaf);
          this.captureLeafState(leaf);
          const newLeaf = this.createNewLeafInPanelOrNull(leaf);
          if (newLeaf) {
            this.app.workspace.revealLeaf(newLeaf);
            this.markAsPreview(newLeaf);
            this.captureLeafState(newLeaf);
          }
          return;
        }
      }
      this.markAsPreview(leaf);
      this.captureLeafState(leaf);
    }
  }
  isDailyNoteFile(file) {
    const datePattern = /^\d{4}-\d{2}-\d{2}/;
    return datePattern.test(file.basename);
  }
};
var PreviewModeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Italic title").setDesc("Show preview tabs with italic title").addToggle((t) => t.setValue(this.plugin.settings.useItalicTitle).onChange(async (v) => {
      this.plugin.settings.useItalicTitle = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Reuse empty tab").setDesc("Reuse empty tabs for preview").addToggle((t) => t.setValue(this.plugin.settings.reuseEmptyTab).onChange(async (v) => {
      this.plugin.settings.reuseEmptyTab = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Promote old preview").setDesc("Convert old preview to permanent when opening in empty tab").addToggle((t) => t.setValue(this.plugin.settings.promoteOldPreview).onChange(async (v) => {
      this.plugin.settings.promoteOldPreview = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Focus existing tab").setDesc("Jump to existing tab if file is already open").addToggle((t) => t.setValue(this.plugin.settings.jumpToDuplicate).onChange(async (v) => {
      this.plugin.settings.jumpToDuplicate = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Open new tab at end").setDesc("Open new tabs at the end of tab list").addToggle((t) => t.setValue(this.plugin.settings.openNewTabAtEnd).onChange(async (v) => {
      this.plugin.settings.openNewTabAtEnd = v;
      await this.plugin.saveSettings();
    }));
  }
};
