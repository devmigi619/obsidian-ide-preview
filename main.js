/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => IDEStylePreviewPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// main.ts
var CONFIG = {
  /** 인라인 제목 변경 시 파일명 반영 대기 시간 */
  TITLE_RENAME_DEBOUNCE_MS: 300,
  /** Daily Note 파일명 패턴 */
  DAILY_NOTE_PATTERN: /^\d{4}-\d{2}-\d{2}\.md$/,
  /** CSS 클래스명 */
  CSS_CLASSES: {
    PREVIEW_TAB: "is-preview-tab",
    ACTIVE: "is-active",
    HAS_FOCUS: "has-focus"
  },
  /** 로그 프리픽스 */
  LOG_PREFIX: "[IDE Preview]"
};
function log(message, ...args) {
  console.log(`${CONFIG.LOG_PREFIX} ${message}`, ...args);
}
var IDEStylePreviewPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    // ─────────────────────────────────────────────────────────────────────────
    // 상태
    // ─────────────────────────────────────────────────────────────────────────
    /** Preview 상태인 탭들 */
    this.previewLeaves = /* @__PURE__ */ new WeakSet();
    /** openFile에서 이미 처리한 탭 (setViewState 중복 방지) */
    this.processedByOpenFile = /* @__PURE__ */ new WeakSet();
    /** Ctrl+Click 감지 플래그 */
    this.isCtrlClickPending = false;
    /** 더블클릭으로 연 파일들 (탭 닫을 때 탐색기 정리용) */
    this.filesOpenedByDoubleClick = /* @__PURE__ */ new Set();
    /** 가장 최근에 열린 leaf */
    this.lastActiveLeaf = null;
    /** 제목 변경 debounce 타이머 */
    this.titleRenameTimer = null;
    /** 패치 해제 함수들 */
    this.cleanupFunctions = [];
  }
  // ─────────────────────────────────────────────────────────────────────────
  // 라이프사이클
  // ─────────────────────────────────────────────────────────────────────────
  async onload() {
    log("Plugin loaded");
    this.installPatches();
    this.registerEventHandlers();
  }
  onunload() {
    this.cleanupFunctions.forEach((cleanup) => cleanup());
    this.cleanupFunctions = [];
    this.removeAllPreviewStyles();
    log("Plugin unloaded");
  }
  installPatches() {
    this.patchOpenFile();
    this.patchSetViewState();
    this.patchDetach();
  }
  registerEventHandlers() {
    this.registerFileOpenHandler();
    this.registerClickHandlers();
    this.registerPromotionTriggers();
  }
  // ─────────────────────────────────────────────────────────────────────────
  // 탭 상태 관리
  // ─────────────────────────────────────────────────────────────────────────
  getTabState(leaf) {
    var _a;
    if (((_a = leaf.view) == null ? void 0 : _a.getViewType()) === "empty")
      return "empty";
    if (this.previewLeaves.has(leaf))
      return "preview";
    return "permanent";
  }
  setAsPreview(leaf) {
    this.previewLeaves.add(leaf);
    this.updateTabStyle(leaf);
  }
  setAsPermanent(leaf) {
    this.previewLeaves.delete(leaf);
    this.updateTabStyle(leaf);
  }
  promoteToPermament(leaf) {
    if (!this.previewLeaves.has(leaf))
      return;
    this.setAsPermanent(leaf);
    log("Promoted to permanent:", this.getLeafDebugId(leaf));
  }
  // ─────────────────────────────────────────────────────────────────────────
  // 위치 판단 (사용자 멘탈 모델 기반)
  // ─────────────────────────────────────────────────────────────────────────
  /**
   * Leaf가 사이드바에 있는지 판단
   * - 사용자 관점: "왼쪽/오른쪽 패널"
   * - 구현 세부사항(file-explorer, bookmarks 등)에 의존하지 않음
   */
  getLeafLocation(leaf) {
    const workspace = this.app.workspace;
    const root = leaf.getRoot();
    if (root === workspace.leftSplit || root === workspace.rightSplit) {
      return "sidebar";
    }
    return "main";
  }
  isInSidebar(leaf) {
    return this.getLeafLocation(leaf) === "sidebar";
  }
  // ─────────────────────────────────────────────────────────────────────────
  // 의도 판별
  // ─────────────────────────────────────────────────────────────────────────
  /**
   * 파일 열기 의도 판별
   * - create: 새 노트 생성, Daily Note 등 → Permanent
   * - browse: 탐색 목적 → Preview
   */
  determineOpenIntent(file, openState) {
    var _a, _b;
    if (((_a = openState == null ? void 0 : openState.eState) == null ? void 0 : _a.rename) === "all") {
      return "create";
    }
    if (((_b = openState == null ? void 0 : openState.state) == null ? void 0 : _b.mode) === "source") {
      if (CONFIG.DAILY_NOTE_PATTERN.test(file.name)) {
        return "create";
      }
    }
    return "browse";
  }
  // ─────────────────────────────────────────────────────────────────────────
  // Leaf 탐색
  // ─────────────────────────────────────────────────────────────────────────
  /**
   * 같은 탭 그룹 내에서 특정 파일이 열린 탭 찾기
   */
  findLeafWithFile(filePath, inSameGroupAs) {
    const siblings = this.getSiblingLeaves(inSameGroupAs);
    for (const sibling of siblings) {
      if (this.getFilePath(sibling) === filePath) {
        return sibling;
      }
    }
    return null;
  }
  /**
   * 같은 탭 그룹 내에서 Preview 탭 찾기
   */
  findPreviewLeaf(inSameGroupAs) {
    const siblings = this.getSiblingLeaves(inSameGroupAs);
    for (const sibling of siblings) {
      if (this.previewLeaves.has(sibling)) {
        return sibling;
      }
    }
    return null;
  }
  /**
   * 같은 탭 그룹의 형제 탭들 가져오기
   */
  getSiblingLeaves(leaf) {
    var _a;
    const internal = leaf;
    const children = (_a = internal.parent) == null ? void 0 : _a.children;
    if (!children)
      return [];
    return children.filter((child) => child !== leaf);
  }
  // ─────────────────────────────────────────────────────────────────────────
  // openFile 패치
  // ─────────────────────────────────────────────────────────────────────────
  patchOpenFile() {
    const plugin = this;
    const uninstall = around(import_obsidian.WorkspaceLeaf.prototype, {
      openFile(original) {
        return async function(file, openState) {
          return plugin.handleOpenFile(this, file, openState, original);
        };
      }
    });
    this.cleanupFunctions.push(uninstall);
    log("Patched openFile");
  }
  async handleOpenFile(leaf, file, openState, originalMethod) {
    const currentState = this.getTabState(leaf);
    const intent = this.determineOpenIntent(file, openState);
    const isCtrlClick = this.consumeCtrlClickFlag();
    const shouldBePermanent = intent === "create" || isCtrlClick;
    log(`openFile: ${file.path}`);
    log(`  state=${currentState}, intent=${intent}, permanent=${shouldBePermanent}`);
    if (this.getFilePath(leaf) === file.path) {
      log("  \u2192 Same file, skipping");
      return;
    }
    const existingLeaf = this.findLeafWithFile(file.path, leaf);
    if (existingLeaf && intent === "browse" && !isCtrlClick) {
      log("  \u2192 Already open, focusing existing tab");
      this.app.workspace.setActiveLeaf(existingLeaf, { focus: true });
      return;
    }
    if (shouldBePermanent) {
      if (currentState === "permanent" || currentState === "preview") {
        return this.openInNewTab(leaf, file, openState, true, originalMethod);
      }
      this.markAsProcessed(leaf);
      const result2 = await originalMethod.call(leaf, file, openState);
      this.setAsPermanent(leaf);
      return result2;
    }
    const existingPreview = this.findPreviewLeaf(leaf);
    if (existingPreview) {
      log("  \u2192 Reusing existing preview tab");
      this.markAsProcessed(existingPreview);
      const result2 = await originalMethod.call(existingPreview, file, openState);
      this.app.workspace.setActiveLeaf(existingPreview, { focus: true });
      return result2;
    }
    if (currentState === "permanent") {
      return this.openInNewTab(leaf, file, openState, false, originalMethod);
    }
    this.markAsProcessed(leaf);
    const result = await originalMethod.call(leaf, file, openState);
    this.setAsPreview(leaf);
    return result;
  }
  async openInNewTab(_fromLeaf, file, openState, asPermanent, originalMethod) {
    log("  \u2192 Opening in new tab");
    const newLeaf = this.app.workspace.getLeaf("tab");
    this.markAsProcessed(newLeaf);
    const result = await originalMethod.call(newLeaf, file, openState);
    if (asPermanent) {
      this.setAsPermanent(newLeaf);
    } else {
      this.setAsPreview(newLeaf);
    }
    this.app.workspace.setActiveLeaf(newLeaf, { focus: true });
    return result;
  }
  // ─────────────────────────────────────────────────────────────────────────
  // setViewState 패치 (비파일 뷰 처리)
  // ─────────────────────────────────────────────────────────────────────────
  patchSetViewState() {
    const plugin = this;
    const uninstall = around(import_obsidian.WorkspaceLeaf.prototype, {
      setViewState(original) {
        return async function(viewState, eState) {
          return plugin.handleSetViewState(this, viewState, eState, original);
        };
      }
    });
    this.cleanupFunctions.push(uninstall);
    log("Patched setViewState");
  }
  async handleSetViewState(leaf, viewState, eState, originalMethod) {
    if (this.wasProcessed(leaf)) {
      this.clearProcessed(leaf);
      return originalMethod.call(leaf, viewState, eState);
    }
    const viewType = viewState == null ? void 0 : viewState.type;
    if (viewType === "markdown" || viewType === "empty") {
      return originalMethod.call(leaf, viewState, eState);
    }
    if (this.isInSidebar(leaf)) {
      return originalMethod.call(leaf, viewState, eState);
    }
    const currentState = this.getTabState(leaf);
    log(`setViewState: type=${viewType}, state=${currentState}`);
    if (currentState === "permanent") {
      const newLeaf = this.app.workspace.getLeaf("tab");
      const result2 = await originalMethod.call(newLeaf, viewState, eState);
      this.setAsPreview(newLeaf);
      return result2;
    }
    const result = await originalMethod.call(leaf, viewState, eState);
    this.setAsPreview(leaf);
    return result;
  }
  // ─────────────────────────────────────────────────────────────────────────
  // detach 패치 (탭 닫힘 처리)
  // ─────────────────────────────────────────────────────────────────────────
  patchDetach() {
    const plugin = this;
    const uninstall = around(import_obsidian.WorkspaceLeaf.prototype, {
      detach(original) {
        return function() {
          const path = plugin.getFilePath(this);
          if (path && plugin.filesOpenedByDoubleClick.has(path)) {
            plugin.clearFileExplorerSelection(path);
            plugin.filesOpenedByDoubleClick.delete(path);
          }
          return original.call(this);
        };
      }
    });
    this.cleanupFunctions.push(uninstall);
    log("Patched detach");
  }
  // ─────────────────────────────────────────────────────────────────────────
  // 이벤트 핸들러
  // ─────────────────────────────────────────────────────────────────────────
  registerFileOpenHandler() {
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        var _a;
        if (!file)
          return;
        const activeLeaf = this.getActiveLeaf();
        if (((_a = activeLeaf == null ? void 0 : activeLeaf.view) == null ? void 0 : _a.getViewType()) === "markdown") {
          this.lastActiveLeaf = activeLeaf;
        }
      })
    );
  }
  registerClickHandlers() {
    this.registerDomEvent(document, "click", (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && this.isFileElement(evt.target)) {
        this.isCtrlClickPending = true;
      }
    }, true);
    this.registerDomEvent(document, "dblclick", (evt) => {
      this.handleDoubleClick(evt);
    }, true);
  }
  handleDoubleClick(evt) {
    const target = evt.target;
    if (target.closest(".workspace-tab-header")) {
      const activeLeaf = this.getActiveLeaf();
      if (activeLeaf && this.previewLeaves.has(activeLeaf)) {
        log("Tab header double-click \u2192 promote");
        this.promoteToPermament(activeLeaf);
      }
      return;
    }
    const sidebarContent = target.closest(".workspace-leaf-content");
    if (sidebarContent) {
      const leaf = this.findLeafByContentEl(sidebarContent);
      if (leaf && this.isInSidebar(leaf)) {
        if (this.lastActiveLeaf && this.previewLeaves.has(this.lastActiveLeaf)) {
          const path = this.getFilePath(this.lastActiveLeaf);
          log("Sidebar double-click \u2192 promote:", path);
          this.promoteToPermament(this.lastActiveLeaf);
          if (path) {
            this.filesOpenedByDoubleClick.add(path);
          }
        }
        return;
      }
    }
    if (target.closest(".graph-view-container")) {
      if (this.lastActiveLeaf && this.previewLeaves.has(this.lastActiveLeaf)) {
        log("Graph double-click \u2192 promote");
        this.promoteToPermament(this.lastActiveLeaf);
      }
    }
  }
  registerPromotionTriggers() {
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor, info) => {
        const leaf = info.leaf;
        if (leaf && this.previewLeaves.has(leaf)) {
          log("Editor change \u2192 promote");
          this.promoteToPermament(leaf);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        this.app.workspace.iterateAllLeaves((leaf) => {
          if (this.getFilePath(leaf) === file.path && this.previewLeaves.has(leaf)) {
            log("File renamed \u2192 promote");
            this.promoteToPermament(leaf);
          }
        });
      })
    );
    this.registerDomEvent(document, "input", (evt) => {
      this.handleInlineTitleEdit(evt);
    }, true);
  }
  handleInlineTitleEdit(evt) {
    var _a, _b;
    const target = evt.target;
    if (!target.classList.contains("inline-title"))
      return;
    const activeLeaf = this.getActiveLeaf();
    if (!activeLeaf)
      return;
    if (this.previewLeaves.has(activeLeaf)) {
      log("Inline title edit \u2192 promote");
      this.promoteToPermament(activeLeaf);
    }
    this.scheduleFileRename(activeLeaf, (_b = (_a = target.textContent) == null ? void 0 : _a.trim()) != null ? _b : "");
  }
  scheduleFileRename(leaf, newTitle) {
    const currentPath = this.getFilePath(leaf);
    if (!currentPath || !newTitle)
      return;
    if (this.titleRenameTimer) {
      window.clearTimeout(this.titleRenameTimer);
    }
    this.titleRenameTimer = window.setTimeout(async () => {
      await this.renameFile(currentPath, newTitle);
    }, CONFIG.TITLE_RENAME_DEBOUNCE_MS);
  }
  async renameFile(currentPath, newTitle) {
    var _a, _b;
    const file = this.app.vault.getAbstractFileByPath(currentPath);
    if (!(file instanceof import_obsidian.TFile))
      return;
    const folder = (_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : "";
    const newPath = folder ? `${folder}/${newTitle}.md` : `${newTitle}.md`;
    if (newPath === currentPath)
      return;
    try {
      log(`Renaming: ${currentPath} \u2192 ${newPath}`);
      await this.app.fileManager.renameFile(file, newPath);
    } catch (e) {
      const message = e instanceof Error ? e.message : String(e);
      log(`Rename failed: ${message}`);
      new import_obsidian.Notice(`\uD30C\uC77C\uBA85 \uBCC0\uACBD \uC2E4\uD328: ${message}`);
    }
  }
  // ─────────────────────────────────────────────────────────────────────────
  // 스타일 관리
  // ─────────────────────────────────────────────────────────────────────────
  updateTabStyle(leaf) {
    const tabHeaderEl = leaf.tabHeaderEl;
    if (!tabHeaderEl)
      return;
    if (this.previewLeaves.has(leaf)) {
      tabHeaderEl.classList.add(CONFIG.CSS_CLASSES.PREVIEW_TAB);
    } else {
      tabHeaderEl.classList.remove(CONFIG.CSS_CLASSES.PREVIEW_TAB);
    }
  }
  removeAllPreviewStyles() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      const tabHeaderEl = leaf.tabHeaderEl;
      tabHeaderEl == null ? void 0 : tabHeaderEl.classList.remove(CONFIG.CSS_CLASSES.PREVIEW_TAB);
    });
  }
  // ─────────────────────────────────────────────────────────────────────────
  // 파일 탐색기 정리
  // ─────────────────────────────────────────────────────────────────────────
  clearFileExplorerSelection(path) {
    var _a, _b;
    const explorerView = this.getFileExplorerView();
    const fileExplorer = document.querySelector(".nav-files-container");
    if (((_b = (_a = explorerView == null ? void 0 : explorerView.activeDom) == null ? void 0 : _a.file) == null ? void 0 : _b.path) === path) {
      log("Clearing explorer activeDom:", path);
      explorerView.activeDom = null;
    }
    if (fileExplorer) {
      const fileItem = fileExplorer.querySelector(`[data-path="${path}"]`);
      if (fileItem) {
        fileItem.classList.remove(CONFIG.CSS_CLASSES.ACTIVE);
        fileItem.classList.remove(CONFIG.CSS_CLASSES.HAS_FOCUS);
      }
    }
  }
  getFileExplorerView() {
    let view = null;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      if (((_a = leaf.view) == null ? void 0 : _a.getViewType()) === "file-explorer") {
        view = leaf.view;
      }
    });
    return view;
  }
  // ─────────────────────────────────────────────────────────────────────────
  // 유틸리티
  // ─────────────────────────────────────────────────────────────────────────
  getFilePath(leaf) {
    const view = leaf.view;
    if (view instanceof import_obsidian.FileView && view.file) {
      return view.file.path;
    }
    return null;
  }
  getLeafDebugId(leaf) {
    var _a;
    return (_a = leaf.id) != null ? _a : "unknown";
  }
  /** activeLeaf의 대체 (deprecated 회피) */
  getActiveLeaf() {
    return this.app.workspace.getMostRecentLeaf();
  }
  isFileElement(target) {
    if (!(target instanceof HTMLElement))
      return false;
    return !!target.closest("[data-path]");
  }
  findLeafByContentEl(contentEl) {
    let found = null;
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      if ((_a = leaf.containerEl) == null ? void 0 : _a.contains(contentEl)) {
        found = leaf;
      }
    });
    return found;
  }
  markAsProcessed(leaf) {
    this.processedByOpenFile.add(leaf);
  }
  wasProcessed(leaf) {
    return this.processedByOpenFile.has(leaf);
  }
  clearProcessed(leaf) {
    this.processedByOpenFile.delete(leaf);
  }
  consumeCtrlClickFlag() {
    if (this.isCtrlClickPending) {
      this.isCtrlClickPending = false;
      return true;
    }
    return false;
  }
};
